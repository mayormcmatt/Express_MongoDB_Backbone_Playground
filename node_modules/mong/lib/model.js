'use strict';

module.exports = Document;

var ObjectId    = require('mongodb').ObjectID;
var QueryStream = require('./stream');
var $private = require('./private').createAccessor();

function Document (o) {
  o = o || {};

  // Cast _id to ObjectId
  if (typeof o._id === 'string') {
    this._id = new ObjectId(o._id);
  } else if (typeof o._id === 'object') {
    this._id = o._id;
  }

  this._id = this._id || new ObjectId();
  
  for(var i in o) {
    if (i !== '_id' && Object.hasOwnProperty.call(o, i)) {
      this[i] = o[i];
    }
  }
}

/**
 * Get Collection
 * @param {Constructor} constructor model constructor
 * @return {MongoDB.Collection}
 */
function GC(constructor) {
  var conInternal = $private(constructor);
  if (!conInternal.collection) {
    conInternal.collection = conInternal.collectionProvider(constructor);
    delete conInternal.collectionProvider;
  }
  return conInternal.collection;
}

// ===== Static Methods =====

/**
 * Set Collection provider function
 * @param  {Constructor -> MongoDB.Collection} provider funciton which gets called once the first time this model is used.
 */
Document.setCollectionProvider = function (provider) {
  $private(this).collectionProvider = provider;
};

/**
 * Set parent connection
 * @param {Connection} connection
 */
Document.setConnection = function (connection) {
  $private(this).connection = connection;
};

Document.find = function (query, fields, options) {
  var collection = GC(this);
  var callback = arguments[arguments.length - 1];
  var l = arguments.length;
  if (typeof callback === 'function') {
    l--;
  } else {
    callback = null;
  }
  switch (l) {
    case 0:
      query = {};
    case 1:
      fields = {};
    case 2:
      options = {};
  }
  var cursor = collection.find.call(collection, query, fields, options);

  if (callback) {
    var proto = this.prototype;
    cursor.toArray(function (err, results) {
      if (err) return callback(err);

      results.forEach(function (doc) {
        doc.__proto__ = proto;
      });

      callback(null, results);
    });
    return;
  }

  return new QueryStream(cursor, this.prototype);
};



Document.findOne = function () {
  var prototype = this.prototype;
  var cb = arguments[arguments.length - 1];
  arguments[arguments.length - 1] = function (err, doc) {
    if (doc) doc.__proto__ = prototype;
    cb(err, doc);
  };
  var collection = GC(this);
  return collection.findOne.apply(collection, arguments);
};

Document.findById = function (_id, callback) {
  if (typeof _id === 'string') _id = new ObjectId(_id);
  return this.findOne({_id: _id}, callback);
};

Document.findAndModify = function (query, sort, update, options, callback) {
  var collection = GC(this);
  return collection.findAndModify.apply(collection, arguments);
};

/**
 * MongoDB aggregation pipeline
 * http://docs.mongodb.org/manual/reference/command/aggregate/#dbcmd.aggregate
 * 
 * @param  [Object]   pipeline
 * @param  {Object}   options  (Optinal)
 * @param  {Function} callback Optional. Leave blank for streaming mode.
 * @return {Readable} stream which emits results.
 */
Document.aggregate = function (pipeline, options, callback) {
  var _callback;
  var l = arguments.length;
  if (typeof arguments[arguments.length - 1] === 'function') {
    _callback = arguments[arguments.length -1];
    l--;
  }
  if (l === 1) {
    options = {};
  }
  var collection = GC(this);
  if (!options.cursor) {
    options.cursor = {};
  }
  var cursor = collection.aggregate(pipeline, options);
  if (_callback) {
    var b = [];
    cursor.on('data', function (data) {
      b.push(data);
    })
    .on('end', function () {
      _callback(null, b);
    });
    return;
  }
  return cursor;
};

/**
 * Create an index.
 * This is the only method which can be used before the connection is open.
 * @param  {Object}   fieldOrSpec
 * @param  {Object}   options
 * @param  {Function} done        callback
 */
Document.ensureIndex = function (fieldOrSpec, options, done) {
  var self = this;
  $private(this).connection.queue(function () {
    var collection = GC(self);
    collection.ensureIndex(fieldOrSpec, options, function (err) {
      if (done) return done(err);
      // Default callback:
      if (err) throw err;
    });
  });
  return this;
};

Document.update = function (query, update, options, callback) {
  var collection = GC(this);
  return collection.update.apply(collection, arguments);
};

Document.remove = function (query, options, callback) {
  var collection = GC(this);
  return collection.remove.apply(collection, arguments);
};


// ===== Instance Methods =====


Document.prototype.save = function (done) {
  done = done || function (err) {
    if (err) throw err;
  };
  var collection = GC(this.constructor);
  var self = this;
  collection.save(this, function (err, numAffected, details) {
    if (err) return done(err);
    done(null, self);
  });
};

Document.prototype.update = function (update, options, callback) {
  var collection = GC(this.constructor);
  var args = [{_id: this._id}].concat(Array.prototype.slice.call(arguments));
  return collection.update.apply(collection, args);
};


Document.prototype.remove = function (options, callback) {
  var collection = GC(this.constructor);
  var args = [{_id: this._id}].concat(Array.prototype.slice.call(arguments));
  return collection.remove.apply(collection, args);
};

/**
 * Update command parametrized by ObjectId(this._id).
 * @param  {Object}   query    additional update conditions
 * @param  {Object}   updates  changes to make. E.g. {$set: {x: 2}}
 * @param  {Object}   options  options
 * @param  {Function} callback
 */
Document.prototype.updateIf = function (query, options, callback) {
  query = Object.create(query);
  query._id = this._id;
  return Document.update.apply(this.constructor, arguments);
};
